/**
 * @file JniUtils.util
 * @author pavl_g.
 * @brief Java Native Interface Utility methods for jni java 8.
 * @version 0.1
 * @date 2022-08-28
 * 
* @copyright 
 * BSD 3-Clause License
 *
 * Copyright (c) 2022, Scrappers Team, The AVR-Sandbox Project, Serial4j API.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef JNI_UTILS
#define JNI_UTILS

#include<jni.h>
#include<stdio.h>
#include<stdlib.h>
#include<stdint.h>

#define CONSTRUCTOR ((const char*) "<init>")

#define NON_PARAMTERIZED_VOID_SIG ((const char*) "()V")
#define NON_PARAMETERIZED_INT_SIG ((const char*) "()I")
#define NON_PARAMETERIZED_STRING_SIG ((const char*) "()[Ljava/lang/String;")
#define NON_PARAMETERIZED_LONG_SIG ((const char*) "()J")

namespace JniUtils {
    static JNIEnv* env;

    /**
     * @brief Sets the Jni Env pointer for jni functions.
     * 
     * @param env the environment pointer to use.
     */
    static inline void setJniEnv(JNIEnv* env) {
        JniUtils::env = env;
    }

    /**
     * @brief Gets the Jni Env pointer.
     * 
     * @return JNIEnv* the namespace env pointer.
     */
    static inline JNIEnv* getJniEnv() {
        return JniUtils::env;
    }

    /**
     * @brief Retrieves a java class from a name, the name is referred to by the
     * package/class, example: {"com/java/io/IOException"}.
     * 
     * @param clazzName the class name using the format {package/class}.
     * @return jclass the reflected java class.
     */
    static inline jclass getClassFromString(const char* clazzName) {
        return JniUtils::getJniEnv()->FindClass(clazzName);
    }

    /**
     * @brief Retrieves a java class method using the [methodName] for the method name
     * and the [sig] for the method signature.
     * 
     * @param clazzName the class name in the format {"package/class"}.
     * @param methodName the method name, use `<init>` for constructors.
     * @param sig the method signature, eg: ()V for non-parameterized void method.
     * @return jmethodID a new method id for the requested method.
     */
    static inline jmethodID getClassMethod(const char* clazzName, const char* methodName, const char* sig) {
        return JniUtils::getJniEnv()->GetMethodID(clazz, methodName, sig);
    }

    static inline jmethodID getClassConstructor0(const char* clazzName, const char* sig) {
        return JniUtils::getJMethodFromClass(clazzName, CONSTRUCTOR, sig);
    }

    static inline jmethodID getClassConstructor1(const char* clazzName) {
        return JniUtils::getClassConstructor0(clazzName, NON_PARAMTERIZED_VOID_SIG);
    }

    static inline void callParameterizedMethod(const char* clazzName, const char* methodName, const char* sig, jvalues* args) {
        jclass clazz = JniUtils::getClassFromString(clazzName);
        jmethodID mid = JniUtils::getClassMethod(clazzName, methodName, sig);
        if (args == NULL) {
            JniUtils::getJniEnv()->CallVoidMethod(clazz, mid);
        } else {
            JniUtils::getJniEnv()->CallVoidMethod(clazz, mid, args);
        }
    }

    static inline void callNonParameterizedMethod(const char* clazzName, const char* sig) {
        JniUtils::callParameterizedMethod(clazzName, methodName, sig, NULL);
    }

    static inline void callParameterizedConstructor(const char* clazzName, const char* sig, jvalues* args) {
        JniUtils::callParameterizedMethod(clazzName, CONSTRUCTOR, sig, args);
    }

    static inline void callNonParameterizedConstructor(const char* clazzName) {
        JniUtils::callParameterizedConstructor(clazzName, NON_PARAMTERIZED_VOID_SIG, NULL);
    }

    static inline jobject getObjectFromClass0(const char* clazzName) {
        return JniUtils::getJniEnv()->AllocObject(JniUtils::getJClassFromString(clazzName));
    }

    static inline jobject getObjectFromClass1(const char* clazzName, jmethodID constructor) {
        return JniUtils::getJniEnv()->NewObject(clazzName, constructor);
    }

    static inline jobject getObjectFromClass2(const char* clazzName) {
        return JniUtils::getObjectFromClass1(clazzName, JniUtils::getClassConstructor1(clazzName));
    }
}

#endif